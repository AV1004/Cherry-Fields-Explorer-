// /*
// Auto-generated by: https://github.com/pmndrs/gltfjsx
// */

import { useLoader } from "@react-three/fiber";
import { useEffect, useState } from "react";
import { GLTFLoader } from "three/examples/jsm/Addons.js";

// import * as THREE from "three";
// import React, { useRef, useState } from "react";
// import { useGLTF } from "@react-three/drei";
// import { GLTF } from "three-stdlib";

// type GLTFResult = GLTF & {
//   nodes: {
//     Object_4: THREE.Mesh;
//     Object_5: THREE.Mesh;
//   };
//   materials: {
//     ["Material.001"]: THREE.MeshStandardMaterial;
//     ["Material.002"]: THREE.MeshStandardMaterial;
//   };
// };

// export function TreeModel(props: JSX.IntrinsicElements["group"]) {
//   const { nodes, materials } = useGLTF("/models/tree.glb") as GLTFResult;
//   const [colorOfLeaves, setColorOfLeaves] = useState("pink");
//   return (
//     <group {...props} dispose={null}>
//       <group position={[-0.386, 0.249, 0.092]} rotation={[-Math.PI / 2, 0, 0]}>
//         <group rotation={[Math.PI / 2, 0, 0]}>
//           <group position={[0.364, 0.327, 0.036]}>
//             <mesh
//               onClick={() => {
//                 if (colorOfLeaves === "pink") {
//                   setColorOfLeaves("green");
//                 } else {
//                   setColorOfLeaves("pink");
//                 }
//               }}
//               castShadow
//               receiveShadow
//               geometry={nodes.Object_4.geometry}
//               material={materials["Material.001"]}
//               material-color={colorOfLeaves}
//             />
//             <mesh
//               castShadow
//               receiveShadow
//               geometry={nodes.Object_5.geometry}
//               material={materials["Material.002"]}
//             />
//           </group>
//         </group>
//       </group>
//     </group>
//   );
// }

// useGLTF.preload("/models/tree.glb");

type treeType = {
  position: { x: number; z: number };
  box: number;
};

type Props = {
  counter: number;
  boundary: number;
};

const Trees: React.FC<Props> = ({ boundary, counter }) => {
  const model = useLoader(GLTFLoader, "./models/tree.glb");
  const [trees, setTrees] = useState<treeType[]>([]);

  const boxIntersect = (
    minAx: number,
    maxAx: number,
    minAz: number,
    maxAz: number,
    minBx: number,
    maxBx: number,
    minBz: number,
    maxBz: number
  ) => {
    let aLeft0fB = maxAx < minBx;
    let aRight0fB = minAx > maxBx;
    let aAboveB = minAz > maxBz;
    let aBelowB = maxAz < minBz;

    return !(aLeft0fB || aRight0fB || aAboveB || aBelowB);
  };

  const isOverLapping = (index: number, tree: any, trees: any[]) => {
    // console.log(tree.position);
    const minTargetX = tree.position.x - tree.box / 2;
    const maxTargetX = tree.position.x + tree.box / 2;
    const minTargetZ = tree.position.z - tree.box / 2;
    const maxTargetZ = tree.position.z + tree.box / 2;

    for (let i = 0; i < index; i++) {
      let minChildX = trees[i].position.x - trees[i].box / 2;
      let maxChildX = trees[i].position.x + trees[i].box / 2;
      let minChildZ = trees[i].position.z - trees[i].box / 2;
      let maxChildZ = trees[i].position.z + trees[i].box / 2;
      if (
        boxIntersect(
          minTargetX,
          maxTargetX,
          minTargetZ,
          maxTargetZ,
          minChildX,
          maxChildX,
          minChildZ,
          maxChildZ
        )
      ) {
        // console.log("Content box Overlapping!", tree.position);
        return true;
      }
    }
    return false;
  };

  const newPosition = (box: number, boundary: number) => {
    return (
      boundary / 2 -
      box / 2 -
      (boundary - box) * (Math.round(Math.random() * 100) / 100)
    );
  };

  const updatePosition = (treeArray: treeType[], boundary: number) => {
    treeArray.forEach((tree, index) => {
      do {
        tree.position.x = newPosition(tree.box, boundary);
        tree.position.z = newPosition(tree.box, boundary);
      } while (isOverLapping(index, tree, treeArray));
    });
    setTrees(treeArray);
  };

  useEffect(() => {
    const tepmTrees: treeType[] = [];
    for (let i = 0; i < counter; i++) {
      tepmTrees.push({ position: { x: 0, z: 0 }, box: 1 });
    }
    updatePosition(tepmTrees, boundary);
  }, [boundary, counter]);

  model.scene.traverse((object) => {
    if (object.isMesh) {
      object.castShadow = true;
    }
  });

  return (
    // // <group rotation={[0, 4.5, 0]}>
    // <object3D position={[0, 0, 0]}>
    //   {/* <object3D position={[-4, 0, 0]} rotation={[1, 1, 0]} scale={[2, 2, 2]}> */}
    //   <primitive object={model.scene} />
    // </object3D>
    // // <object3D position={[-4, 0, 0]}>
    // //   <primitive object={model.scene.clone()} />
    // // </object3D>
    // // <object3D position={[4, 0, 0]}>
    // //   <primitive object={model.scene.clone()} />
    // // </object3D>
    // // </group>

    <group rotation={[0, 0, 0]}>
      {trees.map((tree, index) => {
        return (
          <object3D
            key={index}
            position={[tree.position.x, 0, tree.position.z]}
          >
            <mesh scale={[tree.box, tree.box, tree.box]}>
              <boxGeometry />
              <meshBasicMaterial color={"white"} />
            </mesh>
            <primitive object={model.scene.clone()} />
          </object3D>
        );
      })}
    </group>
  );
};

export default Trees;
